//! # Capture the Flag
//!
//! Capture the Flag is a command-line flag parsing library aimed at producing well
//! documented command-line interfaces with minimal boiler-plate.
//! Flags are defined on the command-line as key-value string pairs which are parsed
//! according to their key name and associated type.
//! Flags can have the form `--key=value` or `--key value`.  If the flag is of type
//! `bool`, the flag can simply use `--key`, which implies `--key=true`.
//! If specified, a flag can have a short form which begins with a single `-`.
//!
//! ## How to use
//!
//! Define a struct where each field represents a flag to parse.
//! The parsing code is generated by deriving the trait [`ctflag::Flags`].
//!
//! ```
//! # use ctflag::Flags;
//! ##[derive(Flags)]
//! struct MyFlags {
//!     enable_floopy: bool,
//!     output: Option<String>,
//! }
//! # fn main() {}
//! ```
//!
//! Parsing the command-line arguments is done by calling the relevant methods of the
//! [`ctflag::Flags`] trait.
//!
//! ```
//! # use ctflag::Flags;
//! # #[derive(Flags)]
//! # struct MyFlags {
//! #     enable_floopy: bool,
//! #     output: Option<String>,
//! # }
//! # fn main() -> ctflag::Result<()> {
//! let (flags, other_args) = MyFlags::from_args(std::env::args())?;
//! # Ok(())
//! # }
//! ```
//!
//! A description of the flags, suitable for use in a help message, can be obtained
//! by calling the [`ctflag::Flags::description()`] method.
//!
//! The behaviour of each flag can be changed using the `#[flag(...)]` attribute.
//!
//! - `desc = "..."`: Provides a description of the flag, displayed in the
//!   help text by the [`ctflag::Flags::description()`] method.
//! - `placeholder = "..."`: Provides the text that appears in place of the
//!   flag's value in the help text. Defaults to "VALUE".
//! - `default = ...`: For types other than `Optional`, provides a default
//!   value if the flag is not set on the command-line. This only works with type
//!   literals (bool, i64, str, etc.).
//! - `short = '...'`: A short, single character alias for the flag name.
//!
//! ```
//! # use ctflag::Flags;
//! ##[derive(Flags)]
//! struct MyFlags {
//!     #[flag(desc = "The floopy floops the whoop")]
//!     enable_floopy: bool,
//!
//!     #[flag(short = 'o', desc = "Output file", placeholder = "PATH")]
//!     output: Option<String>,
//!
//!     #[flag(
//!         desc = "How many slomps to include",
//!         placeholder = "INTEGER",
//!         default = 34
//!     )]
//!     slomps: i64,
//! }
//! # fn main() {}
//! ```
//!
//! The type of each field must implement the [`ctflag::FromArg`] trait.  A blanket
//! implementation of this trait exists for any type implementing the `FromStr` trait.
//!
//! ```
//! # use ctflag::{Flags, FromArg, FromArgError, FromArgResult};
//! // A custom type.
//! enum Fruit {
//!     Apple,
//!     Orange,
//! }
//!
//! impl FromArg for Fruit {
//!     fn from_arg(s: &str) -> FromArgResult<Self> {
//!         match s {
//!             "apple" => Ok(Fruit::Apple),
//!             "orange" => Ok(Fruit::Orange),
//!             _ => Err(FromArgError::with_message("bad fruit")),
//!         }
//!     }
//! }
//!
//! impl Default for Fruit {
//!   fn default() -> Self {
//!       Fruit::Apple
//!   }
//! }
//!
//! ##[derive(Flags)]
//! struct MyFlags {
//!     fruit: Fruit,
//! }
//! # fn main() {}
//! ```
//!
//! [`ctflag::Flags`]: trait.Flags.html
//! [`ctflag::FromArg`]: trait.FromArg.html
//! [`ctflag::Flags::description()`]: trait.Flags.html#tymethod.description

use std::env;
use std::fmt;
use std::str::FromStr;

#[doc(hidden)]
pub use ctflag_derive::*;

#[derive(Clone, Debug)]
pub enum FlagError {
    ParseError(ParseErrorStruct),
    MissingValue(String),
    UnrecognizedArg(String),
}

#[derive(Clone, Debug)]
pub struct ParseErrorStruct {
    pub type_str: &'static str,
    pub input: String,
    pub src: FromArgError,
}

pub type Result<T> = std::result::Result<T, FlagError>;

/// Provides a command-line argument parsing implementation when derived
/// for a named-struct.
///
/// ```
/// # use ctflag::Flags;
/// ##[derive(Flags)]
/// struct MyFlags {
///     enable_floopy: bool,
///     // ...
/// }
/// # fn main() {}
///  ```
///
/// Each field in the struct must implement the [`ctflag::FromArgs`] trait.
///
/// # Default values
///
/// A flag's default value can be specified using the `#[flag(default = ...)]` attribute.
/// This attribute only allows the default value to be a type literal.  For more
/// control over the default value, using an `Option` type is preferred.
/// If this attribute is not set, the type must implement the `Default` trait.
///
/// Implementing this trait by hand is not recommended and would defeat
/// the purpose of this crate.
///
/// [`ctflag::FromArgs`]: trait.FromArgs.html
pub trait Flags: Sized {
    /// Consumes the command-line arguments and returns a tuple containing
    /// the value of this type, and a list of command-line
    /// arguments that were not consumed.  These arguments typically include
    /// the first command-line argument (usually the program name) and any
    /// non-flag arguments (no `-` prefix).
    ///
    /// # Example
    ///
    /// ```
    /// # use ctflag::Flags;
    /// ##[derive(Flags)]
    /// struct MyFlags {
    ///     enable_floopy: bool,
    ///     // ...
    /// }
    ///
    /// # fn main() -> ctflag::Result<()> {
    /// let (flags, args) = MyFlags::from_args(std::env::args())?;
    /// if flags.enable_floopy {
    ///     // ...
    /// }
    /// # Ok(())
    /// # }
    /// ```
    fn from_args(args: env::Args) -> Result<(Self, Vec<String>)>;

    /// Returns a String that describes the flags defined in the struct
    /// implementing this trait.
    ///
    /// For a struct like:
    ///
    /// ```
    /// # use ctflag::Flags;
    /// ##[derive(Flags)]
    /// struct MyFlags {
    ///     #[flag(desc = "The floopy floops the whoop")]
    ///     enable_floopy: bool,
    ///
    ///     #[flag(short = 'o', desc = "Output file", placeholder = "PATH")]
    ///     output: Option<String>,
    ///
    ///     #[flag(
    ///         desc = "How many slomps to include",
    ///         placeholder = "INTEGER",
    ///         default = 34
    ///     )]
    ///     slomps: i64,
    /// }
    /// # fn main() {}
    /// ```
    ///
    /// The returned String looks something like:
    ///
    /// ```text
    /// OPTIONS:
    ///   --enable_floopy        The floopy floops the whoop
    ///   -o, --output [PATH]    Output file
    ///   --slomps INTEGER       How many slomps to include (defaults to 34)
    /// ```
    fn description() -> String;
}

#[derive(Clone, Debug)]
pub struct FromArgError {
    msg: Option<String>,
}

pub type FromArgResult<T> = std::result::Result<T, FromArgError>;

/// Any type declared in a struct that derives [`ctflag::Flags`] must implement
/// this trait.  A blanket implementation exists for types implementing `FromStr`.
/// Custom types can implement this trait directly.
///
/// [`ctflag::Flags`]: trait.Flags.html
///
/// ```
/// # use ctflag::{Flags, FromArg, FromArgError, FromArgResult};
/// enum Fruit {
///     Apple,
///     Orange,
/// }
///
/// impl FromArg for Fruit {
///     fn from_arg(s: &str) -> FromArgResult<Self> {
///         match s {
///             "apple" => Ok(Fruit::Apple),
///             "orange" => Ok(Fruit::Orange),
///             _ => Err(FromArgError::with_message("bad fruit")),
///         }
///     }
/// }
/// ```
pub trait FromArg: Sized {
    /// Parses a string `s` to return the value of this type.
    ///
    /// If parsing succeeds, return the value inside an `Ok`, otherwise
    /// return an error using [`ctflag::FromArgError::with_message`] inside
    /// an `Err`.
    /// [`ctflag::FromArgError::with_message`]: struct.FromArgError.html#method.with_message
    fn from_arg(value: &str) -> FromArgResult<Self>;
}

#[doc(hidden)]
pub fn bool_from_arg(s: Option<&str>) -> FromArgResult<bool> {
    match s {
        Some(s) => s.parse::<bool>().map_err(|_| FromArgError::new()),
        None => Ok(true),
    }
}

#[doc(hidden)]
pub fn option_from_arg<T: FromArg>(s: &str) -> FromArgResult<Option<T>> {
    <T as FromArg>::from_arg(s).map(Some)
}

impl<T> FromArg for T
where
    T: FromStr,
{
    fn from_arg(s: &str) -> FromArgResult<T> {
        <T as FromStr>::from_str(s).map_err(|_| FromArgError::new())
    }
}

impl fmt::Display for FlagError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FlagError::ParseError(err) => {
                write!(
                    f,
                    "failed to parse \"{}\" as {} type",
                    &err.input, err.type_str
                )?;
                if let Some(msg) = &err.src.msg {
                    write!(f, ": {}", msg)?;
                }
            }
            FlagError::MissingValue(arg) => {
                write!(f, "missing value for argument \"{}\"", arg)?;
            }
            FlagError::UnrecognizedArg(arg) => {
                write!(f, "unrecognized argument \"{}\"", arg)?;
            }
        }
        Ok(())
    }
}

impl FromArgError {
    fn new() -> Self {
        FromArgError { msg: None }
    }

    pub fn with_message<T>(msg: T) -> Self
    where
        T: fmt::Display,
    {
        FromArgError {
            msg: Some(format!("{}", msg)),
        }
    }
}
